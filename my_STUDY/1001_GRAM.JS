//자바스크립트 왜 쓸까? => 주 목적 !! HTML변경하려고
//함수 ? => 긴 코드를 짧게 축약하고 싶어서!
//함수이름(파라미터)=>{뭔가내용 = 파라미터} :  하면 함수(파라미터)를 실행할때 파라미터를 넣어서 해줌
//화살표함수 ()=>{} 는 기본 함수랑 약간 다른 기능
//forEach = > [어떤 어레이].forEach()하면 바로 반복문 실행 가능!
//[어떤 어레이].forEach(function(){어레이 개수(길이)만큼 이 안의 내용 반복!}) *어레이에만 붙일 수 있다.
//[어떤 어레이].forEach(function(파라미터){하면 파라미터는 어레의 안의 내용이 된다.1됐다가 2됐다가..})

//this 할떄 나오는 {window}는 기본 함수들의 수납공간.

//'use strict' <= 자바스크립트의 strict 모드. 엄격한 규칙 적용. 변수 var업시 선언도 안먹힘.

var obj = {
    data : 'me',
    함수 : function(){
        console.log(this);
    }
}

obj.함수(); <- 이렇게 하면 오브젝트 내의 함수를 쓸 수 있다! 소괄호 꼭 붙이기!!

//오브젝트 안의 함수(=메소드) 안에서 this를 치면? => 이 this는 메소드가 동작하고 있는 (나를 포함하는) 오브젝트!!
//=>그래서 this를 치면 오브젝트가 반환된다.
//그럼?

var obj = {
    data : {
        
        함수 : function(){
        console.log(this);
      }
  }
}
    
오브젝트 안의 오브젝트의 디스는?

//obj.data.함수(); => obj.data 가 된다! obj아님!! 함수가 있는 바로 그 오브젝트까지만 나옴.


var obj = {
    data : {
        함수 : ()=>{
        console.log(this);
      }
  }
}

//이렇게 화살표함수를 쓰면? 함수 밖에 있던 디스를 줌. 
//obj.data.함수() => 윈도우를 줘버린다...! 내 부모, 오브젝트의 상위요소를 주기 때문에

//오브젝트 안에 함수 넣을때 신문법 = 화살표 함수 아님

var obj = {
    data : {
        함수(){ //그냥 이렇게 써버려도 괜찮아
        console.log(this);
      }
  }
}

즉 우리가 자바스크립트를 작성하는 환경은

window:{
    함수(){console.log(this)}
}

이렇게 window라는 거대 오브젝트 안에서 작성하고 있다는 것.
=>그래서 전역에 this를 하면 윈도우가 나오는것!!

function 오브젝트기계(){ // = constructor
    this.이름 = '이름' //<=여기서 this는 오브젝트 기계가 만드는 오브젝트를 뜻함 = 인스턴스
}

let 오브젝트 = new 오브젝트기계(); //=> 기계 {이름:'이름'} 이렇게 나온다.


addEventListener('이벤트',function(){
    this; //<=이벤트리스너 안에서 this 를 치면 e.currentTarget 이 나온다!!
})

//그러니까 e.currentTarget는 지금 이벤트가 일어나는 html을 뜻한다.

document.querySelector('.뭔가').addEventListener('click', function(e){
    var arr = [1,2,3]
    arr.forEach(function(e){
        console.log(this) //=>여기서 나오는 것은? 정답 window! 왜냐면 내가 동작하는 (눌린)곳이 지금 html전역이니까!
    })
})

var 오브젝트 ={
    이름 : ['1','2','3'],
    함수 : function(){
         console.log(this)// 이건 오브젝트를 출력해줌! 이 함수의 주인.
        오브젝트.이름.forEach(function(){
            console.log(this) //이건 ? window가 됨!!
            //근데 ()=>{}화살표 함수로 바꾸면 오브젝트가 됨.
            //왜냐면 화살표함수는 바로 상위 오브젝트 출력해주니까.
        })
    }
}

오브젝트.함수(); //이렇게 하면 오브젝트 내 디스값을 포함한 함수를 쓸 수 있다.
//왜냐면 이 디스값을 포함한 함수는 일반함수! = 즉 전역함수랑 똑같이 작동한다


//화살표 함수의 사용법을 알아보자

1. function 함수(){} 
2. var 함수 = function(){}

3. var 함수 = ()=>{} // 이게 화살표함수

함수(); //쓸때도 똑같이

//함수를 만드는 이유는!
//1. 코드들을 기능으로 묶고 싶을 때 사용
//2. 입출력 기계를 만들고 싶을 때 사용 = 즉 1넣으면 +10해서 11 나오는 기능 같은거.

var 함수 = ( a )=>{return a + 10 } //이렇게 쓸 수 있다. 편리!

var 함수 =  파라미터 =>{return 파라미터 + 10 } //근데 파라미터 한개면 소괄호 생략 가능!

var 함수 =  파라미터 => 파라미터 + 10 //근데 또 리턴값도 하나면 중괄호에 리턴까지 생략 가능!

//예시

[1,2,3,4].forEach(function(){
    console.log(a) //1,2,3,4 차례로 나옴
})


[1,2,3,4].forEach( a => console.log(a) ) //이렇게 화살표 함수로 쓸 수 있어!

//얘도 축약해볼까?
document.querySelector('.뭔가').addEventListener('click', (e) => {
}) //이렇게 쓰면됨!

//근데 함수 내의 this값을 변경시키지 않기때문에 = 상위의 this값을 가져오기 때문에
//함수안에서 this값을 쓰고싶을때는 쓰면 안돼.


var 오브젝트 ={

    함수 : ()=>{}, //이렇게 오브젝트 안에서도 화살표 함수를 쓸 수 있어~
}





//콜백함수

setTimeout(콜백함수, ms단위의 시간)


function 함수(){
    console.log('안녕')
  }
  
  setTimeout(함수, 1000)
  이렇게 콜백함수 대신 내가 미리 만들어놓은 함수의 이름을 적어도 실행됩니다.
  
  다만 콜백함수자리에 내가만들어놓은 함수를 입력하고 싶으면 소괄호는 빼셔야합니다. 
  
  setTimeout 개념정리 끝입니다. 

