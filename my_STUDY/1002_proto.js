//왔다 프로토타입

function 기계(이름) {
  this.name = 이름;
  this.age = 15;
} //얘가 부모고

var 새로운 = new 기계(기계입니다); //얘가 자식

//이게 상속인데
//상속을 시키는 또 하나의 방법은
//prototype!! = 유전자!!

기계.prototype; //이러면 뭐가 나오네?
//콘스트럭터를 만들면 프로토타입이라는 공간이 자동으로 생겨서 그래!
//이게 콘스트럭터에 새겨진 유전자라구.

//그래서 프로토타입에 값을 추가하면 모든 자식들이 물려받을 수 있다.
//유전자니까..

기계.prototype.인사 = "안녕?";
//이러면 유전자에 등록한게 되어서
//새로운.인사 하면 '안녕?' 이 나와!

//근데 오브젝트 안에서는 안보인다!!

//원리가 뭔데...!
//그냥 자바스크립트가 코드를 그렇게 실행한대.
//이런 프로토타입 = 유전자는 자바스크립트만 가지고 있어.
//그니까 일단 자식한테.없는유전자를 물어보면
//찾아보는데 없어.. 그럼 포기 안하고
//부모유전자를 뒤져본다구! 그래서 프로토타입.을 붙이면 찾아주는거야!

//근데 부모도 없으면 그 부모한테도 물어보고...대단

//자바스크립트의 내장함수인 .sort() 나 .join() 등등 이런거 다
//맨 위의 부모인 Array가 유전자에 이걸 가지고 있어서!!!

var arr = [1, 2, 3]; //즉 이건
var arr = new Array(1, 2, 3); //즉 이거랑 똑같은거고
//그러니까 어레이 생성기계인 Array가 가진 유전자인 내장함수를 다 쓸 수 있다구.

//오브젝트도 똑같아! 부모 오브젝트가 있는거라구.

//그럼 이제 특징도 알아볼까!

//프로토타입은 함수(기계)에만 생성된다구.

//근데 자식이 내 유전자 뭔지 검사하고 싶으면?

__proto__;

자식1.__proto__; //=> 이렇게 치면 부모의 프로토타입이 막 나온다.
부모.prototype; //이거랑 똑같은 뜻임.

//즉~

var Bumo = {
  name: "kim",
};

var Jasic = {}; //나도 김 쓰고싶은데?

Jasic.__proto__ = 부모; //이러면 부모 강제 등록 가능!!

Jasic.name; //이러면 kim나옴!!

//근데 알아만 놔. 잘 안 써.

//각 오브젝트들은 오브젝트라는 최종부모가 있기때문에
//콘솔로 검사해보면 __proto__ 가 있다. 거기에 오브젝트의 유전자가 있어!



//근데 es5부터 더 쉬운 상속기능이 있다구?

//사실 프로토타입이랑 함수기계 이런거 다 옛날문법임.

Object.create();

//얘 뭐야?

Object.create(프로토타입으로쓸오브젝트);//이렇게 쓰는거.

var 부모 = {
    name : 'kim',
    age : 50
} //이걸로 자식 만들고 싶어...

var 자식 = Object.create(부모); 
//이러면 자식 쳐도 {} 이거 나오고 아무것도 없음 ㅎㅎ
//근데? 자식.name 하면 'kim'나옴!!

//이거 안에 속성은 못바꿔?

자식.age = 20; //이렇게 바꾸면 바꿀 수 있지!

//와 쉽다

// 자식의 자식도 만들수 있다

var 손자 = Object.create(자식); //이렇게 만들면 되지!

손자.name //이러면 똑같이 'kim' 나오지~
손자.age //이거는 자식의 속성을 가져왔기 때문에 20나온다구.


// 근데 es6에서 왜 더 어려워졌어?


//이게 진짜 constructor 다!!
//~es6편~
class 부모 { 
    constructor(){
        this.name = '이름'
    }

}

//즉
//클래스 쓰고 이름 쓰고 안에 콘스트럭터 쓰고
//안에 내용 쓰면 돼~

var 자식 = new 부모(); //이렇게 자식 만들수 있지.


//함수 추가하고 싶으면?

//방법은 두가지

class 부모 { 
    constructor(파라미터이름){
        this.name = 파라미터이름
        this.sayHi = function(){} //여기 넣던가?
    }
    sayHi(){}// 아님 여기 넣던가!
}


//근데 콘스트럭터 바깥에 넣으면 그냥 유전자에만 추가됨.
//즉~ 컨스트럭터 바깥은 그냥 프로토타입 영역이라는것! 출력하면 안보임.


자식.__proto__//이러면 뭐가 나올까? 부모 유전자 아닐까?
//맞음. 똑같아.

Object.getPrototypeOf(자식);
//이건 즉 자식의 부모 유전자 호출해줘!! <- __proto__랑 똑같아~

//class안에 함수 여러개 추가하는 방법?
//그냥 연속으로 막 만들면 되는거 아냐?
//맞아 그래도 돼

부모.prototype.어떤함수(){} //이래도 됨


//오브젝트를 쉽고 간단하게 쓰려고 만든 문법이야~


//싱속의 상속 받는법!!

//extens?? => 클래스를 상속하는 문법!

class 뭔가클래스 {

} //이 안에 내용이 넘 많으면 익스텐즈로 상속하는거야!



class 할머니 {
    constructor(이름){
        this.성 = '김';
        this.이름 = 이름;
    }

} 

var 자식 = new 할머니('연아');

//이러면 일단 클래스 상속시켜준거지?

class 어머니 extends 할머니{
    constructor(){
        this.나이 = 50; //이거 안돼!!
    }
}//이러면 익스텐즈로 비슷한 클래스를 하나 더 만든거야!

var 이모 = new 어머니(); //이러면 되는거 아냐?
//아니 안돼! 이렇게 만들면 this쓸 수 없어!!

//그럼 어떻게 써?

class 어머니 extends 할머니{
    constructor(이름){
        super(이름); //슈퍼 꼭 필요해! 이거 한 쌍이야. 왜냐면 할머니에 있던 속성을 가져오는 거임.
        this.나이 = 50; 
    }
}

//이렇게 쓰는 거라구!!


var 이모 = new 어머니('혜수'); // 이러면 성 이름 나이 다 있어!

//죽 슈퍼는 물려받는 클래스의 콘스트럭터 라는 뜻이라구.

//이게 클래스를 익스텐드해서 클래스를 새로 만든겁니다.
//파라미터 두 개 이상이어도 똑같아. 그냥 잘 쓰기만 하면 돼.

//super()의 또 다른 용도

class 조상{
    constructor(미들네임, 네임){
        this.성 = 'lee'
        this.미들네임 = 미들네임
        this.네임 = 네임
    }

    인사(){
        console.log('안녕'); //이렇게 함수 추가하면
    }
}



class 자손 extends 조상 {
    constructor(미들네임, 네임){
        super(미들네임, 네임);
        this.나이 = 50;
    } //얘도 함수 인사()를 쓸 수 있다.

 //근데 만약 여기 함수를 만들면??
 인사(){
    console.log('안녕하세요'); //함수명을 똑같이 준다고 했을 때 
  //이거는 신세대가 쓰면 안녕하세요를 출력하고
    }

    super.인사(); // <= 함수를 이렇게 가져 올 수도 있어!!
    //이거는 안녕 을 출력한다!
}



var 신세대 = new 자손('돈','조반니'); 



//getter, setter 왜 쓰는거야?

var Bianca = {

    출신 : 'sardina',
    나이 : 30
}

Bianca.나이; //30
//이렇게 꺼내는것보다 자료를 꺼내는 법을 만들어서 꺼내보자구.


var Bianca = {

    출신 : 'sardina',
    나이 : 30,
    nextAge(){ //이건 내년 나이 함수
        return this.나이 +1;
    } 

    setAge(다른나이){
        return this.나이 = 다른나이;
    } //이렇게 함수를 만들어두면 오브젝트 안의 데이터를 거를 수도 있어.
    //함수 안에 if써서 숫자만 거를 수도 있고.. 다양함.
    //즉 이건 안전장치라구~
}

Bianca.nextAge() //이러면 31.
//근데 이걸 왜 만들었지?

//편하려고! 오브젝트 자료가 복잡하면 이렇게 하는 게 더 이득이지.
//그리고 업데이트, 자료수정할 때 편해. 왜냐면 자료 넣을 때 실수할 수도 있잖아?

Bianca.setAge(31); //이러면 수정도 되지!


//데이터를 꺼내거나 수정하거나 편리하고 실수도 방지할 수 있어. 관리도 쉽지!
//그래서 이렇게 하는거야.


//근데 이것도 옛날.. es5부터는!!


var Bianca = {

    출신 : 'sardina',
    나이 : 30,
    get nextAge(){ //get, 혹은 set을 붙이면!!
        return this.나이 +1;
    } 

    set setAge(다른나이){
        return this.나이 = 다른나이;
    } 
}

Bianca.setAge = 32; //set 붙인건 이렇게 소괄호 없이 사용 가능하고

Bianca.nextAge; //get붙인 건 이렇게 바로 쓰면 된다구! 소괄호 떼줘.



//얘 특징 뭐야?

//get은 return 하고 세트야. 꼭 리턴을 주도록 해.
//그리고 겟은 파라미터가 필요 없어.

//set은 파라미터가 하나 이상 꼭 필요해. 파라미터를 꼭 주자!

//게다가 클래스에서도 사용 가능해. 


class 새로운사람{
    constructor(){
        this.이름 = '김';
        this.나이 = 20;
    }

   get 내년나이(){
        return this.나이 +1
    }

}

var 행인 = new 새로운사람();

행인.내년나이; //21. 이런식으로 클래스에서 활용 가능!

//set 도 똑같아~




