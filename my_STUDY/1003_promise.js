//브라우저 동작원리 이벤트루프를 알아보자구

console.log(1+1) //얘가 1번
setTimeout(function(){console.log(2+2)},1000) //얘는 1초 뒤에!!
console.log(3+3) //얘가 2번

//어 중간에 안 멈추고 세번째 줄 먼저 실행하네? 왜 이렇게 동작하지...? 

//stack 에 작업할게 막 쌓여 (힙에사 막 자료 꺼내쓰고..)=>이게 싱글스레드라는 뜻임
//근데 setTimeout이나 이벤트리스너 ajax요청코드 이런게 들어오면 처리가 넘 오래걸리잖아! 
//그러면 대기실(브라우저 api)에 넣음
//그리고 처리가 끝나면 QUEUE에 넣어줌!! 큐는 다음에 스택이 텅 비었을 때 코드를 보내준다구.

//즉~ 스택에 코드가 들어오면~ 셋타임아웃 빼고 실행하면서 셋타임아웃은 대기실->큐->스택이 비면 스택에
//이렇게 되는거다.
 
setTimeout(function(){console.log(2+2)},0) //어 그럼 0초면 바로 실행되는거 아냐?
//아님!! 셋타임아웃을 만나면 무.조.건 뒤로 보낸다구!!그래서 마지막에 처리됨.

//그니까 스택을 바쁘게 하지 말자.. 무한FOR문 돌리고 이러면 스택이 안 비어서 멈춰버린다구.
//근데 다음에 큐가 막 쌓이면??? 완전 큰일남
//그리고 큐도 바쁘게 하지 말자. 버튼 하나에 이벤트 100개 붙이고 이러면 바빠진다구

//암튼 setTimeout, addEventListener, Ajax 함수 이런거 쓰면 비동기 처리가 가능함.



//그래서 아무튼 sync 이건 동기식처리(synchronous)라는 뜻임.

//Async 는? 비동기식(Asynchronous) 처리라는 뜻이다.

console.log(1+1) //얘가 1번
setTimeout(()=>{console.log(2+2)},1000) //얘는 1초 뒤에!!
console.log(3+3) //얘가 2번

// 그니까 이게 비동기식 처리(async)임..!

addEventListener('click',function(){}) //이것도 비동기식.

$.ajax() //이거 제이쿼리인데 이것도 비동기식.

//얘네 만나면 Web API 로 보내짐. 대기실이야.

//web api와 관련된 함수들 덕분에 오래걸리는 처리 할 동안 다른거부터 실행 가능한것!!
//웹페이지 프리징시키지 말고 활용을 하자구.


//음 근데 난 순차적으로 실행시키고 싶은데.=> 콜백함수 쓰세요

setTimeout(()=>{console.log(2+2)},1000) //애초에 이게 콜백함수야

//간단하게 함수 안에 함수 들어간거가 콜백함수. 람다함수로 넣어도 되고~ 다른데서 넣은 함수 넣으면 되고~


setTimeout(함수이름,1000) //근데 다른데서 함수 만들어서 넣을때는 ()이거 빼기(이건 실행해달라는 뜻)


//예를들어 봐봐

function 첫째함수(구멍){ //이게 콜백함수를 넣는 방법
    console.log(1)
    구멍(); //여기에 둘째함수가 쏙 들어가겠지?
}

function 둘째함수(){
    console.log(2)
}

// 이거 첫째함수 실행한 다음에 둘째함수 실행해줘~ 하고싶으면??
//그냥 순차적으로 하면 되는거 아니에요? =>아니? 안에 처리가 얼마나 걸리는지 모르잖아?

첫째함수(둘째함수); //=> 이러면 되지! 이게 콜백함수 만드는 법!

//주의~ 콜백함수는 비동기 이런거 아니고 함수 디자인 패턴일 뿐임.



첫째함수(function 여기이름도넣어(){ //이렇게도 만들수있다! 근데 위에거가 보기 예쁘잖아
    어쩌구
});


첫째함수(function(){ //이렇게도 할 수 있는데 개 난잡하잖아...!!
    둘째함수(function(){
        셋째함수(function(){

        })
    })
})



//근데 이거 예쁘게 만들 수 있는 방법이 있어..!
//그게 promie~  디자인 패턴임

var 프로미스 = new Promise(); //뉴 프로미스 부르면 만들 수 있지

프로미스.then(function(){ //프로미스. 가 성공하면 실행해줘~

})

//콜백함수랑 비슷하지??근데..!
프로미스.then(function(){ 
}).then().then() //이렇게 막 이어도 되고

프로미스.then().catch() //캐치는 뭐야? 실패했을때 이거 실행시켜줘 뜻임!!
.finally()//성공 실패 상관없이 아무튼 이건 꼭 실행해!

//대단해 프로미스는 성공실패판정 기계로구나

//만들어보자

var 성공실패기계 = new Promise(function(성공, 실패){ // 얘네 두 개 뚫어주고 성공 : resolve , 실패 : reject
    성공(); //이거 쓰면 반드시 성공함
    실패(); //이거 쓰면 반드시 실패함
});

//성공 써놓으면 than 이 실행되고, 실패하면 catch가 실행됨!!

성공실패기계.then().catch() 

var 성공실패기계 = new Promise(function(성공, 실패){ // 얘네 두 개 뚫어주고 성공 : resolve , 실패 : reject
    var 어려운연산 = 1+1; //이거 끝나면
    성공(); //성공 판정 내려줘(실행시켜줘)
});

성공실패기계.then(function(){
    console.log('성공했다')
}).catch(function(){
    console.log('실패함')
})


//저 뉴 프로미스 안에 
실패(); //이거 쓰면 실패함이 뜨겠지? 그렇게 쓰는거임~

성공(10); //이렇게 파라미터를 넣으면? than 안에 전달해줄수도 있어~

//이렇게!!

var 성공실패기계 = new Promise(function(성공, 실패){
    var 어려운연산 = 1+1; 
    성공(어려운연산);
});

성공실패기계.then(function(결과){
    console.log(결과) //이러면 2 나오겠지?
}).catch(function(){
    console.log('실패함')
})


//실감나는 예시

var 성공실패기계 = new Promise(function(성공, 실패){
    setTimeout(function(){ //1초 후에 성공을 네려주는 프로미스
        성공();
    },1000)
});

성공실패기계.then(function(){
    console.log('성공함')
}).catch(function(){
    console.log('실패함')
})


//특징 정리

//프로미스는 일종의 오브젝트인데
//3가지 상태가 있어!

pending //성공 실패 판정 아직 안함 (대기중)

resolved //성공함! 

rejected //실패함!

//콘솔창에 보면 상태가 계속 변해! 한 번 봐봐

//즉 바로 위도 셋타임아웃 걸린 시간은 펜딩
//결과 내리면 리솔브드 혹은 리젝티드로 바뀜!!


//프로미스 왜 써?
//이렇게 짜려고...
//비동기적 처리로 바꿔주는 문법이 아니야! 이 안에서 비동기 처리를 도와주는 함수를 쓸 수 있을 뿐.
//코딩스타일...콜백함수의 대체품이라구.

$.ajax().done(function(){}).fail()..//이런거 제이쿼리인데 이거랑 비슷하지?


//하나더

fetch()// 이거 쓴 자리에 반드시 프로미스를 리턴함. 이 자리에 프로미스가 남는다구!

fetch().then().catch() //이런식으로 쓰면됨


//연속으로 성공 하고싶으면 어떻게 하는데요??


var 프로미스 = new Promise((성공, 실패)=>{
    뭔가의요청어쩌구함수라던지의결과(성공(결과))
});

프로미스.then((결과)=>{여기에(결과);

    return new Promise((s,f)=>{
        여기에도어쩌구(s(결과))
    })

}).then((결과)=>{결과});


//이러면돼!!

//아아 then(new Promise())하면 프로미스를 연속으로 쓸 수 있구나!


//근데 안에 자꾸 돌지 않아? 함수로 만들까?


function 에이젝스해주는함수(함수링크){
    return new Promise((s,f)=>{
        $.get(함수링크).done(function(결과){s(결과)})
    })
}

에이젝스해주는함수(함수링크).then(
   (결과)=>{console.log(결과)
   return 에이젝스해주는함수(함수링크)}).then((결과)=>{console.log(결과)})

   //와 이래도 되나봐!!!

// 에이젝스해주는 함수? = fatch임 이거 공부해보기


//나왔다 
//Promise 어려워서 싫으면 async/await을사용합시다

//es8부터 제공하는 엄청난 문법

//일반적으로 함수 쓸때말야
function 더하기(콜백함수){
    1 + 1
    콜백함수() //이런식으로 계산한 후에 콜백함수를 넣어서
}

더하기(콜백함수); //이런식으로 순차실행 시키잖아?

//근데 프로미스로 바꿀수있다?

async function 어려운더하기(){  //async 를 함수 앞에 붙여봐!! 그럼 프로미스 됨!!
    1 + 1;
}

어려운더하기().then(function(){console.log('성공이에요!')})

//async를 함수 앞에 붙이면 함수 실행 후에 promise오브젝트가 남는다!!

async function 에이싱크(){
    return 2 + 2 //이렇게 리턴 붙이면?
}

에이싱크().then(function(결과){console.log(결과)}) //여기에 결과도 띄울 수 있어!

//단점 성공만 할 수 있음 ㅎㅎㅎㅎ

return Promise.reject('실패임')//이러면 강제로 실패 판정 할 수 있음
//근데 뭔 결과를 준다기보다 그냥 에러남 실행 안됨


//어웨잇이 뭐야? 이거 같이 써봐봐


async function 에이싱크야(){

    var 프로미스 = new Promise((s,f)=>{
        var 힘든연산 = 1 + 1; 
        s();
        
    })

    프로미스.then(()=>{console.log('성공함')})
}

//이런 함수를 만들었다 쳐봐봐 근데 더 예쁘게 쓸 수 있다?


async function 에이싱크야(){

    var 프로미스 = new Promise((s,f)=>{
        var 힘든연산 = 1 + 1; 
        s(결과);
        
    })

    //프로미스.then(()=>{console.log('성공함')})

    var 결과 = await 프로미스;
    console.log(결과); //와 이렇게 쓰면 되는구나!!
    //저 위 성공 판정이 난 후 나온 결과를 여기 변수에 넣어줄수 있어.
}

에이싱크야(); 

//await 기다려! 라는 뜻~ 프로미스 해결되길 기다려 라는 뜻!

//이렇게 쓰면 완전 된다구! 


//근데 얘도 프로미스가 실패reject하면 에러나고 멈춰..!
//프로미스랑 같이 써도 그럼. 그냥 에이싱크랑 어웨잇 세트니까 같다고 알아줘


//실패판정도 주고싶은데 어떡해?

try{이걸 해보고 에러나면} catch{이거해주세요} //이런 애 쓰면 돼!

async function 확실한더하기(){
    var 나는프로미스 = new Promise((s,f)=>{
        var 매우힘든연산 = 3 + 3
        f(결과); //이거 분명 에러나잖아? 에이싱크인데.
    });
    
    try{ //그니까 이거 해보고 에러나면

        var 진짜결과 = await 나는프로미스;
        console.log(결과); //에러났으니까 에러걸리는 대신
    } 
    
    catch{

        console.log('프로미스 연산 안됐구나?') //이거 실행해줄걸!

    }
    
}

//만약 프로미스가 성공이면 try 실행해주겠지!


//예제풀어보자
//버튼을 누르면 성공판정하는 promise

async function test(){

    var 프로미스 = new Promise((s,f)=>{
        document.querySelector('#button')
        .addEventListener('click',()=>{
            s('눌렸습니다!');
        })
    });

    try{  var 버튼눌러 = await 프로미스;
          alert(버튼눌러);  }
    catch{
        alert('안눌림...');
    } 

}

//와 정답이야!!


//근데 이걸 굳이 만들어야돼?
//콜백함수로도 되긴 해. 근데 코드 길어지면 이게 더 유용하겠지?
//순차적으로 많은 것들을 실행할 때 유용해.


//for in / for of 반복문과 enumerable, iterable 속성
//이거 배워보도록 하자.

//반복문의 용도는 두개
//1. 코드 단순 반복
//2.자료형에 담긴 자료들을 하나씩 꺼내고 싶을때

for(var i = 0; i < 3 ; i++) //어려움...

[].forEach(); //그래서 어레이 전용 어레이에 붙이는 포이치문도 나왔고

for (var key in 오브젝트) //오브젝트 전용 오브젝트를 돌 수 있는 포인문도 나왔지

for (var key of 오브젝트) // 이터러블 전용! 이터러블? 그게 뭐지? 아무튼.


//for in 부터

var 비앙카 = { name : 'bianca', age : 30 };

for(var 작명 in 비앙카){
    console.log(비앙카[작명]) //와 이렇게 하면 키값만 나와!!
} // = 오브젝트.key 이거랑 똑같아~


//특징!
//1. 이뉴머러블 ( enumerrable )한 데이터만 반복해줘.
//뭔소리야?

//저기에는 보이지 않는 숨겨진 자료들도 있어.
//키값 하나에 뭐 얘가 재설정 가능한지 반복 가능한지.. 그런 정보가 있다.
//enumerrable : true 면 반복 가능한 속성이라는 뜻

//특징 2. 부모의 프로토타입도 반복해줘!

class rosanna {

}

rosanna.prototype.name = 'medici';

var bianca = new rosanna();


for( var key in bianca){
    console.log(bianca[key]) }//medici 나옴. 엇 부모의 프로토타입인데 빼내줬네?

//이게 포인 반복문의 쓰잘데기 기능임.. 부모 프로토타입까지는 안보고싶으면

for( var key in bianca){
   if (bianca.hasOwnProperty(key)) //이거 쓰면 내가 가진 키값만 보여줘.
    {console.log(bianca[key])} }//그럼 아무것도 출력 안되겠지? 비앙카 아무것도 없어..

//다만 해즈온프로퍼티는 불린으로 출력(참/거짓) 해주기 때문에
//반복문에 쓸거면 if문 줘라.

//특징 3. 오브젝트 자료형에만 씁니당....!
//어레이는? 포나 포이치 쓰세요.

//얘 그럼 필요 없는거 아니에요? 아니
//어레이, 문자, arguments, nodelist, map, set 
//이런데 다 쓸 수 있어!!

var arr = [1,2,3,4,5]

for(var 자료 of arr){
    console.log(자료)
} //자료 변수가 1,2,3, 이렇게 바뀌어서 나와. 와~

//문자도 됨

for(var 자료 of '우와아아아ㅏ'){
    console.log(자료)
} //우 와 아 ㅏ  로 출력됨 ㅋㅋ


//어디다 써요? iterable 한 자료형에만 사용 가능!!

//iterable ?

어레이.[Symbol.iterator]() //이거 치면 iterator 이거 속성에 나와 신기하지
//그냥 반복하게 해주는 속성..이라고 생각하면 됨
//이거 속성 있으면 포오브 쓸 수 있어.

document.querySelector();
document.getElementById(); //이런거 쓰면 [이런식으로 남는데]
//어레이는 아니지만 []이거 안에 들어가면서 이터러블한 속성이 생김. 그래서 되는거야.

//예제 하나..
//포오브로 구구단 출력하기

let 데이터 = [1,2,3,4,5,6,7,8,9] 
// for of는 array 이런거 반복문 돌릴 때 쓰랬으니 필요한 array데이터는 드림 

for(var 구구단 of 데이터){ //어레이 한번 돌때
    for(var 구구구단 of 데이터){ //얘를 아홉번 돌면서
        console.log(`${구구단} x ${구구구단} = ${구구단*구구구단}`)
    } //콘솔로그 찍어줌!
    
}

//어 했어!!!!!!!!!!!!!!! 나 풀었어!!!!!


//예제 2.

var products = [
    {
      name1 : 'chair',
      price1 : 7000,
    },
    {
      name2 : 'sofa',
      price : 5000,
    },
    {
      name1 : 'desk',
      price3 : 9000,
    },
  ]; 
//   Q. 어떤 놈이 key값 마지막 부분에 오타를 섞어놨습니다.
  
//   key값 마지막에 한자릿수 숫자가 섞여있으면 그걸 다 제거하고 싶습니다. 
  
//   어떻게 코드를 짜면 될까요? 
  
//   마지막 글자가 숫자인지 판단하는 방법도 잘 찾아봐야겠군요.
//그니까 검사를 두 번 해야되는건 어레이 돌다가 안에 오브젝트 들어가야 해서.
//구구단 할때랑 똑같아!
//이거 다시 풀어보기 이해가 안되나봐



isNaN(parseInt('123')) 

이걸 사용하면 대충 이게 숫자형 문자인지 판단이 가능합니다.

NaN은 문자에 숫자연산하려고하면 나오는 이상한 자료형이며 isNaN은 NaN인지 판정해줍니다. 

그래서 저기에 '123' 이걸 집어넣으면 false가 남습니다. 

그래서 저기에 '가나다' 이걸 집어넣으면 true가 남습니다. 

 
//힌트
 

처음부터 반복문 돌리는게 익숙치않은 초보라면

하나만 하드코딩해보십시오 그리고 그걸 반복문돌리는게 훨씬 쉽습니다. 

그래서 저도 테스트삼아서 object 자료 하나만 해봤습니다.

1. name1 여기 가장 뒷자리 문자가 숫자인지 확인합니다.

2. 그게 숫자면 일단 newValue, newKey를 만들어줍니다.

3. newKey는 맨 뒷 문자를 제거해줍니다.

그리고 기존 오브젝트에 { newKey : newValue } 데이터를 추가해줍니다. 

4. 마지막으로 delete 키워드 쓰면 object에 있던 property 지울 수 있습니다. 




